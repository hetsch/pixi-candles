{"version":3,"file":"Plot.js","sourceRoot":"","sources":["Plot.ts"],"names":[],"mappings":"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","sourcesContent":["import {Buffer, Geometry, Program, Texture, Renderer} from '@pixi/core';\nimport {CanvasRenderer} from '@pixi/canvas-renderer';\nimport {Mesh, MeshMaterial} from '@pixi/mesh';\nimport {createIndicesForQuads, hex2string} from '@pixi/utils';\nimport {LINE_JOIN, LINE_CAP} from '@pixi/graphics';\nimport {TYPES} from '@pixi/constants';\n\nexport enum JOINT_TYPE {\n    NONE = 0,\n    FILL = 1,\n    JOINT_BEVEL = 4,\n    JOINT_MITER = 8,\n    JOINT_ROUND = 12,\n    JOINT_CAP_BUTT = 16,\n    JOINT_CAP_SQUARE = 18,\n    JOINT_CAP_ROUND = 20,\n    FILL_EXPAND = 24,\n    CAP_BUTT = 1 << 5,\n    CAP_SQUARE = 2 << 5,\n    CAP_ROUND = 3 << 5,\n    CAP_BUTT2 = 4 << 5,\n}\n\nexport enum LINE_SCALE_MODE {\n    NONE = 'none',\n    NORMAL = 'normal',\n    HORIZONTAL = 'horizontal',\n    VERTICAL = 'vertical',\n}\n\nconst plotVert = `precision highp float;\nconst float FILL = 1.0;\nconst float BEVEL = 4.0;\nconst float MITER = 8.0;\nconst float ROUND = 12.0;\nconst float JOINT_CAP_BUTT = 16.0;\nconst float JOINT_CAP_SQUARE = 18.0;\nconst float JOINT_CAP_ROUND = 20.0;\n\nconst float FILL_EXPAND = 24.0;\n\nconst float CAP_BUTT = 1.0;\nconst float CAP_SQUARE = 2.0;\nconst float CAP_ROUND = 3.0;\nconst float CAP_BUTT2 = 4.0;\n\n// === geom ===\nattribute vec2 aPrev;\nattribute vec2 aPoint1;\nattribute vec2 aPoint2;\nattribute vec2 aNext;\nattribute float aVertexJoint;\nattribute float vertexNum;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\n\nvarying vec4 vDistance;\nvarying vec4 vArc;\nvarying float vType;\n\nuniform float resolution;\nuniform float expand;\nuniform float miterLimit;\nuniform float scaleMode;\nuniform vec2 styleLine;\n\nvec2 doBisect(vec2 norm, float len, vec2 norm2, float len2,\n    float dy, float inner) {\n    vec2 bisect = (norm + norm2) / 2.0;\n    bisect /= dot(norm, bisect);\n    vec2 shift = dy * bisect;\n    if (inner > 0.5) {\n        if (len < len2) {\n            if (abs(dy * (bisect.x * norm.y - bisect.y * norm.x)) > len) {\n                return dy * norm;\n            }\n        } else {\n            if (abs(dy * (bisect.x * norm2.y - bisect.y * norm2.x)) > len2) {\n                return dy * norm;\n            }\n        }\n    }\n    return dy * bisect;\n}\n\nvoid main(void){\n    vec2 pointA = (translationMatrix * vec3(aPoint1, 1.0)).xy;\n    vec2 pointB = (translationMatrix * vec3(aPoint2, 1.0)).xy;\n\n    vec2 xBasis = pointB - pointA;\n    float len = length(xBasis);\n    vec2 forward = xBasis / len;\n    vec2 norm = vec2(forward.y, -forward.x);\n\n    float type = aVertexJoint;\n\n    float lineWidth = styleLine.x;\n    if (scaleMode > 2.5) {\n        lineWidth *= length(translationMatrix * vec3(1.0, 0.0, 0.0));\n    } else if (scaleMode > 1.5) {\n        lineWidth *= length(translationMatrix * vec3(0.0, 1.0, 0.0));\n    } else if (scaleMode > 0.5) {\n        vec2 avgDiag = (translationMatrix * vec3(1.0, 1.0, 0.0)).xy;\n        lineWidth *= sqrt(dot(avgDiag, avgDiag) * 0.5);\n    }\n    float capType = floor(type / 32.0);\n    type -= capType * 32.0;\n    vArc = vec4(0.0);\n    lineWidth *= 0.5;\n    float lineAlignment = 2.0 * styleLine.y - 1.0;\n\n    vec2 pos;\n\n    if (capType == CAP_ROUND) {\n        if (vertexNum < 3.5) {\n            gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n            return;\n        }\n        type = JOINT_CAP_ROUND;\n        capType = 0.0;\n    }\n\n    if (type >= BEVEL) {\n        float dy = lineWidth + expand;\n        float inner = 0.0;\n        if (vertexNum >= 1.5) {\n            dy = -dy;\n            inner = 1.0;\n        }\n\n        vec2 base, next, xBasis2, bisect;\n        float flag = 0.0;\n        float sign2 = 1.0;\n        if (vertexNum < 0.5 || vertexNum > 2.5 && vertexNum < 3.5) {\n            next = (translationMatrix * vec3(aPrev, 1.0)).xy;\n            base = pointA;\n            flag = type - floor(type / 2.0) * 2.0;\n            sign2 = -1.0;\n        } else {\n            next = (translationMatrix * vec3(aNext, 1.0)).xy;\n            base = pointB;\n            if (type >= MITER && type < MITER + 3.5) {\n                flag = step(MITER + 1.5, type);\n                // check miter limit here?\n            }\n        }\n        xBasis2 = next - base;\n        float len2 = length(xBasis2);\n        vec2 norm2 = vec2(xBasis2.y, -xBasis2.x) / len2;\n        float D = norm.x * norm2.y - norm.y * norm2.x;\n        if (D < 0.0) {\n            inner = 1.0 - inner;\n        }\n\n        norm2 *= sign2;\n\n        if (abs(lineAlignment) > 0.01) {\n            float shift = lineWidth * lineAlignment;\n            pointA += norm * shift;\n            pointB += norm * shift;\n            if (abs(D) < 0.01) {\n                base += norm * shift;\n            } else {\n                base += doBisect(norm, len, norm2, len2, shift, 0.0);\n            }\n        }\n\n        float collinear = step(0.0, dot(norm, norm2));\n\n        vType = 0.0;\n        float dy2 = -1000.0;\n        float dy3 = -1000.0;\n\n        if (abs(D) < 0.01 && collinear < 0.5) {\n            if (type >= ROUND && type < ROUND + 1.5) {\n                type = JOINT_CAP_ROUND;\n            }\n            //TODO: BUTT here too\n        }\n\n        if (vertexNum < 3.5) {\n            if (abs(D) < 0.01) {\n                pos = dy * norm;\n            } else {\n                if (flag < 0.5 && inner < 0.5) {\n                    pos = dy * norm;\n                } else {\n                    pos = doBisect(norm, len, norm2, len2, dy, inner);\n                }\n            }\n            if (capType >= CAP_BUTT && capType < CAP_ROUND) {\n                float extra = step(CAP_SQUARE, capType) * lineWidth;\n                vec2 back = -forward;\n                if (vertexNum < 0.5 || vertexNum > 2.5) {\n                    pos += back * (expand + extra);\n                    dy2 = expand;\n                } else {\n                    dy2 = dot(pos + base - pointA, back) - extra;\n                }\n            }\n            if (type >= JOINT_CAP_BUTT && type < JOINT_CAP_SQUARE + 0.5) {\n                float extra = step(JOINT_CAP_SQUARE, type) * lineWidth;\n                if (vertexNum < 0.5 || vertexNum > 2.5) {\n                    dy3 = dot(pos + base - pointB, forward) - extra;\n                } else {\n                    pos += forward * (expand + extra);\n                    dy3 = expand;\n                    if (capType >= CAP_BUTT) {\n                        dy2 -= expand + extra;\n                    }\n                }\n            }\n        } else if (type >= JOINT_CAP_ROUND && type < JOINT_CAP_ROUND + 1.5) {\n            if (inner > 0.5) {\n                dy = -dy;\n                inner = 0.0;\n            }\n            vec2 d2 = abs(dy) * forward;\n            if (vertexNum < 4.5) {\n                dy = -dy;\n                pos = dy * norm;\n            } else if (vertexNum < 5.5) {\n                pos = dy * norm;\n            } else if (vertexNum < 6.5) {\n                pos = dy * norm + d2;\n                vArc.x = abs(dy);\n            } else {\n                dy = -dy;\n                pos = dy * norm + d2;\n                vArc.x = abs(dy);\n            }\n            dy2 = 0.0;\n            vArc.y = dy;\n            vArc.z = 0.0;\n            vArc.w = lineWidth;\n            vType = 3.0;\n        } else if (abs(D) < 0.01) {\n            pos = dy * norm;\n        } else {\n            if (type >= ROUND && type < ROUND + 1.5) {\n                if (inner > 0.5) {\n                    dy = -dy;\n                    inner = 0.0;\n                }\n                if (vertexNum < 4.5) {\n                    pos = doBisect(norm, len, norm2, len2, -dy, 1.0);\n                } else if (vertexNum < 5.5) {\n                    pos = dy * norm;\n                } else if (vertexNum > 7.5) {\n                    pos = dy * norm2;\n                } else {\n                    pos = doBisect(norm, len, norm2, len2, dy, 0.0);\n                    float d2 = abs(dy);\n                    if (length(pos) > abs(dy) * 1.5) {\n                        if (vertexNum < 6.5) {\n                            pos.x = dy * norm.x - d2 * norm.y;\n                            pos.y = dy * norm.y + d2 * norm.x;\n                        } else {\n                            pos.x = dy * norm2.x + d2 * norm2.y;\n                            pos.y = dy * norm2.y - d2 * norm2.x;\n                        }\n                    }\n                }\n                vec2 norm3 = normalize(norm + norm2);\n\n                float sign = step(0.0, dy) * 2.0 - 1.0;\n                vArc.x = sign * dot(pos, norm3);\n                vArc.y = pos.x * norm3.y - pos.y * norm3.x;\n                vArc.z = dot(norm, norm3) * lineWidth;\n                vArc.w = lineWidth;\n\n                dy = -sign * dot(pos, norm);\n                dy2 = -sign * dot(pos, norm2);\n                dy3 = vArc.z - vArc.x;\n                vType = 3.0;\n            } else {\n                float hit = 0.0;\n                if (type >= BEVEL && type < BEVEL + 1.5) {\n                    if (dot(norm, norm2) > 0.0) {\n                        type = MITER;\n                    }\n                }\n\n                if (type >= MITER && type < MITER + 3.5) {\n                    if (inner > 0.5) {\n                        dy = -dy;\n                        inner = 0.0;\n                    }\n                    float sign = step(0.0, dy) * 2.0 - 1.0;\n                    pos = doBisect(norm, len, norm2, len2, dy, 0.0);\n                    if (length(pos) > abs(dy) * miterLimit) {\n                        type = BEVEL;\n                    } else {\n                        if (vertexNum < 4.5) {\n                            dy = -dy;\n                            pos = doBisect(norm, len, norm2, len2, dy, 1.0);\n                        } else if (vertexNum < 5.5) {\n                            pos = dy * norm;\n                        } else if (vertexNum > 6.5) {\n                            pos = dy * norm2;\n                        }\n                        vType = 1.0;\n                        dy = -sign * dot(pos, norm);\n                        dy2 = -sign * dot(pos, norm2);\n                        hit = 1.0;\n                    }\n                }\n                if (type >= BEVEL && type < BEVEL + 1.5) {\n                    if (inner > 0.5) {\n                        dy = -dy;\n                        inner = 0.0;\n                    }\n                    float d2 = abs(dy);\n                    vec2 pos3 = vec2(dy * norm.x - d2 * norm.y, dy * norm.y + d2 * norm.x);\n                    vec2 pos4 = vec2(dy * norm2.x + d2 * norm2.y, dy * norm2.y - d2 * norm2.x);\n                    if (vertexNum < 4.5) {\n                        pos = doBisect(norm, len, norm2, len2, -dy, 1.0);\n                    } else if (vertexNum < 5.5) {\n                        pos = dy * norm;\n                    } else if (vertexNum > 7.5) {\n                        pos = dy * norm2;\n                    } else {\n                        if (vertexNum < 6.5) {\n                            pos = pos3;\n                        } else {\n                            pos = pos4;\n                        }\n                    }\n                    vec2 norm3 = normalize(norm + norm2);\n                    float sign = step(0.0, dy) * 2.0 - 1.0;\n\n                    dy = -sign * dot(pos, norm);\n                    dy2 = -sign * dot(pos, norm2);\n                    dy3 = (-sign * dot(pos, norm3)) + lineWidth;\n                    vType = 4.0;\n                    hit = 1.0;\n                }\n                if (hit < 0.5) {\n                    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n                    return;\n                }\n            }\n        }\n\n        pos += base;\n        vDistance = vec4(dy, dy2, dy3, lineWidth) * resolution;\n        vArc = vArc * resolution;\n    }\n\n    gl_Position = vec4((projectionMatrix * vec3(pos, 1.0)).xy, 0.0, 1.0);\n}`;\n\nconst plotFrag = `precision highp float;\nvarying vec4 vDistance;\nvarying vec4 vArc;\nvarying float vType;\nuniform vec4 uColor;\n\nvoid main(void){\n    float alpha = 1.0;\n    float lineWidth = vDistance.w;\n    if (vType < 0.5) {\n        float left = max(vDistance.x - 0.5, -vDistance.w);\n        float right = min(vDistance.x + 0.5, vDistance.w);\n        float near = vDistance.y - 0.5;\n        float far = min(vDistance.y + 0.5, 0.0);\n        float top = vDistance.z - 0.5;\n        float bottom = min(vDistance.z + 0.5, 0.0);\n        alpha = max(right - left, 0.0) * max(bottom - top, 0.0) * max(far - near, 0.0);\n    } else if (vType < 1.5) {\n        float a1 = clamp(vDistance.x + 0.5 - lineWidth, 0.0, 1.0);\n        float a2 = clamp(vDistance.x + 0.5 + lineWidth, 0.0, 1.0);\n        float b1 = clamp(vDistance.y + 0.5 - lineWidth, 0.0, 1.0);\n        float b2 = clamp(vDistance.y + 0.5 + lineWidth, 0.0, 1.0);\n        alpha = a2 * b2 - a1 * b1;\n    } else if (vType < 2.5) {\n        alpha *= max(min(vDistance.x + 0.5, 1.0), 0.0);\n        alpha *= max(min(vDistance.y + 0.5, 1.0), 0.0);\n        alpha *= max(min(vDistance.z + 0.5, 1.0), 0.0);\n    } else if (vType < 3.5) {\n        float a1 = clamp(vDistance.x + 0.5 - lineWidth, 0.0, 1.0);\n        float a2 = clamp(vDistance.x + 0.5 + lineWidth, 0.0, 1.0);\n        float b1 = clamp(vDistance.y + 0.5 - lineWidth, 0.0, 1.0);\n        float b2 = clamp(vDistance.y + 0.5 + lineWidth, 0.0, 1.0);\n        float alpha_miter = a2 * b2 - a1 * b1;\n\n        float alpha_plane = max(min(vDistance.z + 0.5, 1.0), 0.0);\n\n        float d = length(vArc.xy);\n        float circle_hor = max(min(vArc.w, d + 0.5) - max(-vArc.w, d - 0.5), 0.0);\n        float circle_vert = min(vArc.w * 2.0, 1.0);\n        float alpha_circle = circle_hor * circle_vert;\n\n        alpha = min(alpha_miter, max(alpha_circle, alpha_plane));\n    } else {\n        float a1 = clamp(vDistance.x + 0.5 - lineWidth, 0.0, 1.0);\n        float a2 = clamp(vDistance.x + 0.5 + lineWidth, 0.0, 1.0);\n        float b1 = clamp(vDistance.y + 0.5 - lineWidth, 0.0, 1.0);\n        float b2 = clamp(vDistance.y + 0.5 + lineWidth, 0.0, 1.0);\n        alpha = a2 * b2 - a1 * b1;\n        alpha *= max(min(vDistance.z + 0.5, 1.0), 0.0);\n    }\n    gl_FragColor = uColor * alpha;\n}\n`;\n\nexport class PlotShader extends MeshMaterial {\n    static _prog: Program = null;\n\n    static getProgram(): Program {\n        if (!PlotShader._prog) {\n            PlotShader._prog = new Program(plotVert, plotFrag);\n        }\n        return PlotShader._prog;\n    }\n\n    constructor() {\n        super(Texture.WHITE, {\n            uniforms: {\n                resolution: 1,\n                expand: 1,\n                scaleMode: 1,\n                styleLine: new Float32Array([1.0, 0.5]),\n                miterLimit: 5.0,\n            },\n            program: PlotShader.getProgram()\n        });\n    }\n}\n\nexport function multIndex(indices: Uint32Array, vertCount: number, instanceCount: number, support32 = true) {\n    const size = indices.length;\n    const ind = support32 ? new Uint32Array(size * instanceCount) : new Uint16Array(size * instanceCount);\n    for (let i = 0; i < instanceCount; i++) {\n        for (let j = 0; j < size; j++) {\n            ind[i * size + j] = indices[j] + vertCount * i;\n        }\n    }\n    return ind;\n}\n\nexport class PlotGeometry extends Geometry {\n    constructor(_static = false) {\n        super();\n        this.initGeom(_static);\n        this.reset();\n    }\n\n    joinStyle = LINE_JOIN.MITER;\n    capStyle = LINE_CAP.SQUARE;\n\n    lastLen = 0;\n    lastPointNum = 0;\n    lastPointData = 0;\n    updateId = 0;\n    points: Array<number> = [];\n    _floatView: Float32Array = null;\n    _u32View: Uint32Array = null;\n    _buffer: Buffer = null;\n    _quad: Buffer = null;\n    _indexBuffer: Buffer = null;\n    _vertexNums: Buffer = null;\n    support32 = false;\n\n    initGeom(_static: boolean) {\n        this._buffer = new Buffer(new Float32Array(0), _static, false);\n\n        this._vertexNums = new Buffer(new Float32Array([0, 1, 2, 3, 4, 5, 6, 7, 8]), true, false);\n\n        this._indexBuffer = new Buffer(new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 4, 7, 8]), true, true);\n\n        this.addAttribute('aPrev', this._buffer, 2, false, TYPES.FLOAT, 3 * 4, 0 * 4, true)\n            .addAttribute('aPoint1', this._buffer, 2, false, TYPES.FLOAT, 3 * 4, 3 * 4, true)\n            .addAttribute('aPoint2', this._buffer, 2, false, TYPES.FLOAT, 3 * 4, 6 * 4, true)\n            .addAttribute('aNext', this._buffer, 2, false, TYPES.FLOAT, 3 * 4, 9 * 4, true)\n            .addAttribute('aVertexJoint', this._buffer, 1, false, TYPES.FLOAT, 3 * 4, 5 * 4, true)\n            .addAttribute('vertexNum', this._vertexNums, 1, false, TYPES.FLOAT)\n            .addIndex(this._indexBuffer);\n    }\n\n    stridePoints = 2;\n    strideFloats = 3;\n    strideBytes = 3 * 4;\n\n    moveTo(x: number, y: number) {\n        const {points} = this;\n        points.push(x);\n        points.push(y);\n    }\n\n    lineTo(x: number, y: number) {\n        const {points} = this;\n        points.push(x);\n        points.push(y);\n    }\n\n\n    lineBy(dx: number, dy: number) {\n        const {points, stridePoints} = this;\n\n        const x = points[points.length - stridePoints];\n        const y = points[points.length - stridePoints + 1];\n\n        points.push(x + dx);\n        points.push(y + dy);\n    }\n\n    invalidate(pointNum = 0) {\n        this.lastPointNum = Math.min(pointNum, this.lastPointNum);\n        this.updateId++;\n    }\n\n    reset() {\n        if (this.lastLen > 0) {\n            this.clearBufferData();\n        }\n        this.updateId++;\n        this.lastLen = 0;\n        this.lastPointData = 0;\n        this.points.length = 0;\n        this.instanceCount = 0;\n    }\n\n    clearBufferData() {\n        const {points, strideBytes, stridePoints} = this;\n        this.lastPointNum = 0;\n        this.lastPointData = 0;\n        const arrayLen = Math.max(0, points.length / stridePoints + 3);\n        const arrBuf = new ArrayBuffer(strideBytes * arrayLen);\n        this.lastLen = points.length;\n        this._floatView = new Float32Array(arrBuf);\n        this._u32View = new Uint32Array(arrBuf);\n        this._buffer.update(arrBuf);\n    }\n\n    updateBuffer() {\n        const {points, stridePoints, strideFloats} = this;\n\n        if (this.lastLen > points.length) {\n            this.lastLen = -1;\n        }\n        if (this.lastLen < points.length\n            || this.lastPointNum < this.lastLen) { // TODO: partial upload\n            this.clearBufferData();\n        }\n\n        if (this.lastPointNum == this.lastLen) {\n            return;\n        }\n\n        const jointType = this.jointType();\n        const capType = this.capType();\n        let endJoint = capType;\n        if (capType === JOINT_TYPE.CAP_ROUND) {\n            endJoint = JOINT_TYPE.JOINT_CAP_ROUND;\n        }\n        if (capType === JOINT_TYPE.CAP_BUTT) {\n            endJoint = JOINT_TYPE.JOINT_CAP_BUTT;\n        }\n        if (capType === JOINT_TYPE.CAP_SQUARE) {\n            endJoint = JOINT_TYPE.JOINT_CAP_SQUARE;\n        }\n\n        const {_floatView, _u32View} = this;\n\n        if (this.lastPointNum > 0) {\n            this.lastPointNum--;\n        }\n        if (this.lastPointNum > 0) {\n            this.lastPointNum--;\n        }\n\n        this.lastPointData = Math.min(this.lastPointData, this.lastPointNum);\n        let j = (Math.round(this.lastPointNum / stridePoints) + 2) * strideFloats; //actually that's int division\n\n        // TODO: null points should have extra instance? more than instance on one point?\n\n        for (let i = this.lastPointNum; i < points.length; i += stridePoints) {\n            _floatView[j++] = points[i];\n            _floatView[j++] = points[i + 1];\n\n            if (isNaN(points[i]) || isNaN(points[i + 1])) {\n                // find prev non-nan\n                _floatView[j-2] = (points[i+2] + points[i-2]) * 0.5;\n                _floatView[j-1] = (points[i+3] + points[i-1]) * 0.5;\n                _floatView[j] = 0;\n                j++;\n                continue;\n            }\n\n            _floatView[j] = jointType;\n            if (i == 0) {\n                if (capType !== JOINT_TYPE.CAP_ROUND) {\n                    _floatView[j] += capType;\n                }\n            } else {\n                if (isNaN(points[i - 2]) || isNaN(points[i - 1])) {\n                    _floatView[j] += JOINT_TYPE.CAP_BUTT;\n                }\n            }\n            if (i + stridePoints * 2 >= points.length || isNaN(points[i + 4]) || isNaN(points[i + 5])) {\n                _floatView[j] += endJoint - jointType;\n            } else if (i + stridePoints >= points.length || isNaN(points[i + 2]) || isNaN(points[i + 3])) {\n                _floatView[j] = 0;\n            }\n            j++;\n        }\n        _floatView[j++] = points[points.length - 4];\n        _floatView[j++] = points[points.length - 3];\n        _floatView[j++] = 0;\n        _floatView[0] = points[0];\n        _floatView[1] = points[1];\n        _floatView[2] = 0;\n        _floatView[3] = points[2];\n        _floatView[4] = points[3];\n        _floatView[5] = capType === JOINT_TYPE.CAP_ROUND ? capType : 0;\n\n        //TODO: update from first modified float\n        this._buffer.update();\n        this.instanceCount = Math.round(points.length / stridePoints);\n\n        this.lastPointNum = this.lastLen;\n        this.lastPointData = this.lastLen; // TODO: partial upload\n\n        if (this.legacyGeom) {\n            this.updateLegacy();\n        }\n    }\n\n    legacyGeom: Geometry = null;\n    legacyBuffer: Buffer = null;\n\n    initLegacy(support32: boolean) {\n        if (this.legacyGeom) {\n            return;\n        }\n        const ind = [0, 1, 2, 0, 2, 3];\n        this.support32 = support32;\n        this.legacyGeom = new Geometry();\n        this.legacyBuffer = new Buffer(new Float32Array(0), false, false);\n        this.legacyGeom.addAttribute('aPrev', this.legacyBuffer, 2, false, TYPES.FLOAT)\n            .addAttribute('aPoint1', this.legacyBuffer, 2, false, TYPES.FLOAT)\n            .addAttribute('aPoint2', this.legacyBuffer, 2, false, TYPES.FLOAT)\n            .addAttribute('aNext', this.legacyBuffer, 2, false, TYPES.FLOAT)\n            .addAttribute('aVertexJoint', this.legacyBuffer, 1, false, TYPES.FLOAT)\n            .addAttribute('vertexNum', this.legacyBuffer, 1, false, TYPES.FLOAT)\n            .addIndex(new Buffer(support32? new Uint32Array(ind): new Uint16Array(ind), false, true));\n    }\n\n    updateLegacy() {\n        const {legacyBuffer, _floatView, _u32View, strideFloats} = this;\n        const strideLegacy = 10;\n        const vcount = 9;\n        const instanceCount = (this._floatView.length / strideFloats - 3);\n        const legacyLen = instanceCount * strideLegacy * vcount;\n        if ((legacyBuffer.data as Float32Array).length !== legacyLen) {\n            legacyBuffer.data = new Float32Array(legacyLen);\n            this.legacyGeom.getIndex().update(multIndex(this._indexBuffer.data as any, vcount, instanceCount, this.support32));\n        }\n        const floats: Float32Array = legacyBuffer.data as any;\n        for (let i = 0, j = 0; j < legacyLen; i += strideFloats) {\n            for (let k = 0; k < vcount; k++) {\n                floats[j++] = _floatView[i];\n                floats[j++] = _floatView[i + 1];\n                floats[j++] = _floatView[i + 3];\n                floats[j++] = _floatView[i + 4];\n                floats[j++] = _floatView[i + 6];\n                floats[j++] = _floatView[i + 7];\n                floats[j++] = _floatView[i + 9];\n                floats[j++] = _floatView[i + 10];\n                floats[j++] = _floatView[i + 5];\n                floats[j++] = k;\n            }\n        }\n    }\n\n    /**\n     * copied from graphics-smooth\n     */\n    public capType() {\n        let cap: number;\n\n        switch (this.capStyle) {\n            case LINE_CAP.SQUARE:\n                cap = JOINT_TYPE.CAP_SQUARE;\n                break;\n            case LINE_CAP.ROUND:\n                cap = JOINT_TYPE.CAP_ROUND;\n                break;\n            default:\n                cap = JOINT_TYPE.CAP_BUTT;\n                break;\n        }\n\n        return cap;\n    }\n\n    /**\n     * copied from graphics-smooth\n     */\n    public goodJointType() {\n        let joint: number;\n\n        switch (this.joinStyle) {\n            case LINE_JOIN.BEVEL:\n                joint = JOINT_TYPE.JOINT_BEVEL;\n                break;\n            case LINE_JOIN.ROUND:\n                joint = JOINT_TYPE.JOINT_ROUND;\n                break;\n            default:\n                joint = JOINT_TYPE.JOINT_MITER + 3;\n                break;\n        }\n\n        return joint;\n    }\n\n    /**\n     * copied from graphics-smooth\n     */\n    public jointType() {\n        let joint: number;\n\n        switch (this.joinStyle) {\n            case LINE_JOIN.BEVEL:\n                joint = JOINT_TYPE.JOINT_BEVEL;\n                break;\n            case LINE_JOIN.ROUND:\n                joint = JOINT_TYPE.JOINT_ROUND;\n                break;\n            default:\n                joint = JOINT_TYPE.JOINT_MITER;\n                break;\n        }\n\n        return joint;\n    }\n}\n\nexport interface PlotOptions {\n    lineWidth?: number;\n    nativeLineWidth?: number;\n    joinStyle?: LINE_JOIN;\n    capStyle?: LINE_CAP;\n}\n\nexport interface ILineStyleOptions{\n    color?: number;\n    alpha?: number;\n    width?: number;\n    alignment?: number;\n    scaleMode?: LINE_SCALE_MODE;\n    cap?: LINE_CAP;\n    join?: LINE_JOIN;\n    miterLimit?: number;\n}\n\nexport class Plot extends Mesh {\n    constructor(options: PlotOptions) {\n        const geometry = new PlotGeometry();\n        const shader = new PlotShader();\n        let scaleMode = LINE_SCALE_MODE.NORMAL;\n        if (options) {\n            if (options.lineWidth !== undefined) {\n                shader.uniforms.styleLine[0] = options.lineWidth;\n            }\n            if (options.nativeLineWidth !== undefined) {\n                shader.uniforms.styleLine[0] = options.nativeLineWidth;\n                scaleMode = LINE_SCALE_MODE.NONE;\n            }\n            if (options.joinStyle !== undefined) {\n                geometry.joinStyle = options.joinStyle;\n            }\n            if (options.capStyle !== undefined) {\n                geometry.capStyle = options.capStyle;\n            }\n        }\n\n        super(geometry, shader);\n        this.scaleMode = scaleMode\n    }\n\n    moveTo(x: number, y: number) {\n        const geometry = this.geometry as PlotGeometry;\n        geometry.moveTo(x, y);\n    }\n\n    lineTo(x: number, y: number) {\n        const geometry = this.geometry as PlotGeometry;\n        geometry.lineTo(x, y);\n    }\n\n    lineBy(x: number, y: number) {\n        const geometry = this.geometry as PlotGeometry;\n        geometry.lineBy(x, y);\n    }\n\n    lineStyle(width?: number, nativeWidth?: number, joinStyle?: LINE_JOIN, capStyle?: LINE_CAP) {\n        const param = width as any;\n        if (param instanceof Object) {\n            this.gLineStyle(param);\n            return;\n        }\n\n        const geometry = this.geometry as PlotGeometry;\n        if (width !== undefined) {\n            this.shader.uniforms.styleLine[0] = width;\n            this.scaleMode = LINE_SCALE_MODE.NORMAL\n        }\n        if (nativeWidth !== undefined) {\n            this.shader.uniforms.styleLine[0] = nativeWidth;\n            this.scaleMode = LINE_SCALE_MODE.NONE\n        }\n        if (joinStyle !== undefined) {\n            geometry.joinStyle = joinStyle;\n        }\n        if (capStyle !== undefined) {\n            geometry.capStyle = capStyle;\n        }\n        geometry.invalidate();\n    }\n\n    gLineStyle(obj: ILineStyleOptions) {\n        const geometry = this.geometry as PlotGeometry;\n        if (obj.width !== undefined) {\n            this.shader.uniforms.styleLine[0] = obj.width;\n        }\n        if (obj.alignment !== undefined) {\n            this.shader.uniforms.styleLine[0] = obj.alignment;\n        }\n        if (obj.scaleMode !== undefined) {\n            this.shader.uniforms.scaleMode = obj.scaleMode;\n        }\n        if (obj.color !== undefined) {\n            this.tint = obj.color;\n        }\n        if (obj.join !== undefined) {\n            geometry.joinStyle = obj.join;\n        }\n        if (obj.cap !== undefined) {\n            geometry.capStyle = obj.cap;\n        }\n    }\n\n    set scaleMode(value: LINE_SCALE_MODE) {\n        this._scaleMode = value\n        let intVal = 0;\n        switch (value) {\n            case LINE_SCALE_MODE.NORMAL: intVal = 1; break;\n            case LINE_SCALE_MODE.HORIZONTAL: intVal = 2; break;\n            case LINE_SCALE_MODE.VERTICAL: intVal = 3; break;\n        }\n        this.shader.uniforms.scaleMode = intVal\n    }\n\n    get scaleMode(): LINE_SCALE_MODE {\n        return this._scaleMode\n    }\n\n    private _scaleMode : LINE_SCALE_MODE\n\n    clear() {\n        (this.geometry as PlotGeometry).reset();\n    }\n\n    _renderDefault(renderer: Renderer): void {\n        const geometry = this.geometry as PlotGeometry;\n\n        if (geometry.points.length < 4) {\n            return;\n        }\n\n        const useLegacy = !renderer.geometry.hasInstance;\n        if (useLegacy) {\n            geometry.initLegacy(renderer.context.supports.uint32Indices);\n        }\n        geometry.updateBuffer();\n        if (geometry.instanceCount === 0) {\n            return;\n        }\n        const rt = renderer.renderTexture.current;\n        const multisample = rt ? rt.framebuffer.multisample > 1 : renderer.options.antialias;\n        const resolution = this.shader.uniforms.resolution = (rt ? rt.baseTexture.resolution : renderer.resolution);\n        this.shader.uniforms.expand = (multisample ? 2 : 1) / resolution;\n\n        if (useLegacy) {\n            // hacky!\n            (this as any).geometry = geometry.legacyGeom;\n            super._renderDefault(renderer);\n            (this as any).geometry = geometry;\n            return;\n        }\n        super._renderDefault(renderer);\n    }\n\n    _renderCanvas(renderer: CanvasRenderer): void {\n        const {points, stridePoints, capStyle, joinStyle} = this.geometry as PlotGeometry;\n        const {context} = renderer;\n        const len = points.length;\n        if (len < 2) {\n            return;\n        }\n        const wt = this.transform.worldTransform;\n        renderer.setContextTransform(wt);\n\n        const scale = Math.sqrt(wt.a * wt.a + wt.b * wt.b);\n        context.lineWidth = this.shader.uniforms.styleLine[0] + this.shader.uniforms.styleLine[1] / scale;\n\n        context.strokeStyle = hex2string(this.tint);\n        context.globalAlpha = this.worldAlpha;\n        context.lineCap = capStyle;\n        context.lineJoin = joinStyle;\n\n        context.beginPath();\n        context.moveTo(points[0], points[1]);\n        for (let i = 2; i < points.length; i += stridePoints) {\n            context.lineTo(points[i], points[i + 1]);\n        }\n        context.stroke();\n        context.beginPath();\n\n        context.globalAlpha = 1.0;\n    }\n}\n"]}